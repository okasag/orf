check()
library(orf)
summary(orf)
table(orf$predictedCategories)
table(Y)
plot(orf)
# load data
load("/home/okasag/Documents/HSG/ORF/data_package/survey/survey.Rdata")
# try to take 3 covariates
survey_xy <- survey[, which(colnames(survey) %in% c("Gender", "Age", "Education", "Alcohol", "Healthy.eating", "Smoking", "Passive.sport"))]
# recode the variables
# age
survey_xy$Age <- as.numeric(survey_xy$Age)
# gender
survey_xy$Gender <- ifelse(survey_xy$Gender == "female", 0,
ifelse(survey_xy$Gender == "male", 1, NA))
# education
survey_xy$Education <- ifelse(survey_xy$Education == "currently a primary school pupil", 1,
ifelse(survey_xy$Education == "primary school", 2,
ifelse(survey_xy$Education == "secondary school", 3,
ifelse(survey_xy$Education == "college/bachelor degree", 4,
ifelse(survey_xy$Education == "masters degree", 5,
ifelse(survey_xy$Education == "doctorate degree", 6, NA))))))
# alcohol
survey_xy$Alcohol <- ifelse(survey_xy$Alcohol == "never", 1,
ifelse(survey_xy$Alcohol == "social drinker", 2,
ifelse(survey_xy$Alcohol == "drink a lot", 3, NA)))
# healthy eating
survey_xy$Healthy.eating <- as.numeric(survey_xy$Healthy.eating)
# smoking
survey_xy$Smoking <- ifelse(survey_xy$Smoking == "never smoked", 1,
ifelse(survey_xy$Smoking == "tried smoking", 2,
ifelse(survey_xy$Smoking == "former smoker", 3,
ifelse(survey_xy$Smoking == "current smoker", 4, NA))))
# remove NAs
survey_xy <- survey_xy[complete.cases(survey_xy), ]
# prepare data for orf
# X
X <- as.matrix(cbind(survey_xy$Gender, survey_xy$Age, survey_xy$Education))
# Y
Y <- as.matrix(survey_xy$Passive.sport)
# estimate orf
orffit <- orf(X,Y)
plot(orffit)
# Y
Y <- as.matrix(survey_xy$Active.sport)
# Y
Y <- as.matrix(survey_xy$Smoking)
# estimate orf
orffit <- orf(X,Y)
plot(orffit)
# Y
Y <- as.matrix(survey_xy$Alcohol)
# estimate orf
orffit <- orf(X,Y)
plot(orffit)
# Y
Y <- as.matrix(survey_xy$Healthy.eating)
# estimate orf
orffit <- orf(X,Y)
plot(orffit)
# set working directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
## load dgp function
source("simulate_data_ORF_function.R")
## load dgp function
source("simulate_data_ORF_function.R")
# general simulation settings
n             <- 1000 # sample size
n_test        <- 1000 # test sample size
# number of discrete values for Y (3,6,9)
Y_n           <- 3
# settings for different DGPs (TRUE/FALSE) - use complicated GDP now
noise             <- FALSE # additional noise variables
highdim           <- FALSE # 1000 noise (zero signal) variables
nonlinear         <- FALSE # nonlinear effects as sin(2X)*beta
multi             <- FALSE # multicollinearity of X
randomcuts        <- FALSE # equal or random cutpoints for Y*
# simulate data
sim_data <- ologit_DGP(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts)
# remove everything
rm(list=setdiff(ls(), c("sim_data")))
### estimate standard ologit ###
library(MASS)
library(erer)
# try out ologit
ologit <- polr(Yo ~ ., data = sim_data$odata, Hess = TRUE)
# marginal effects for logit
ologit_me <-ocME(ologit)$out$ME.all
### estimate ORF ###
# load functions
source("ORF_ME_functions.R")
# prepare data as matrices
X <- as.matrix(sim_data$odata[,2:ncol(sim_data$odata)])
Y <- as.matrix(sim_data$odata[,1])
colnames(Y) <- "Y"
ntree <- 1000
mtry <- 5
# estimate ORF marginal effects
system.time(
orf_me <- ORF_ME(X, Y, ntree, mtry, inference = FALSE)
)
### estimate ORF marginal effects with inference ###
system.time(
orf_me_inf <- ORF_ME(X, Y, ntree, mtry, inference = TRUE)
)
### compare: real_me, ologit_me, orf_me, orf_me_inf ###
ologit_me_mse <- sum(colMeans((sim_data$real_me - ologit_me)^2))
orf_me_mse <- sum(colMeans((sim_data$real_me - orf_me$MarginalEffects)^2))
orf_me_inf_mse <- sum(colMeans((sim_data$real_me - orf_me_inf$MarginalEffects)^2))
print(c(ologit_me_mse, orf_me_mse, orf_me_inf_mse))
# compare orf_me with orf_me_inf
diff <- orf_me$MarginalEffects - orf_me_inf$MarginalEffects
round(diff,5)
orf_me_mse
orf_me$MarginalEffects
ologit_me
## libraries
library(mvtnorm)
library(psych)
### ordered logit model DGP
## built a function for ologit DGP
ologit_DGP <- function(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts) {
# set seed
set.seed(3192) # put your birthday here
# number of covariates
n_X           <- 15 # covariates (only 15 fixed so far)
# intercept
b0            <- 0 # true value for the intercept always 0 for ordered model
# effects
betas         <- c(rep(1,5),rep(0.75,5),rep(0.5,5))
# generate covariates
if (multi == TRUE) {
# define possible levels of correlation for Xs
corr_level <- 0.8
# create correlation matrix
corr_matrix <- matrix(0, nrow = n_X, ncol = n_X)
corr_matrix[c(1,3,5,7,9,11,13,15),c(1,3,5,7,9,11,13,15)] <- corr_level # correlation structure as in Janitza
#corr_matrix[,c(1,3,6,8,11,13)] <- corr_level # correlation structure as in Janitza
diag(corr_matrix) <- 1
# generate X
X             <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix), n, n_X)
X_test        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix), n_test, n_X)
} else {
# define possible levels of correlation for Xs
corr_level <- 0
# create correlation matrix
corr_matrix <- matrix(0, nrow = n_X, ncol = n_X)
diag(corr_matrix) <- 1
# generate X
X             <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix), n, n_X)
X_test        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix), n_test, n_X)
}
# noise variables + high dimensional setting
if ((noise == TRUE) & (highdim == TRUE)) {
m_try         <- round(sqrt(1015)) # number of random variables for each split
betas0        <- rep(0,1000) # zero effect for additional noise variables
# create correlation matrix
corr_matrix_noise <- matrix(0, nrow = 1000, ncol = 1000)
corr_matrix_noise[1:3,1:3] <- 0.8 # correlation structure as in Janitza
corr_matrix_noise[4:6,4:6] <- 0.6
corr_matrix_noise[7:10,7:10] <- 0.4
corr_matrix_noise[11:13,11:13] <- 0.2
diag(corr_matrix_noise) <- 1
# generate X
X_noise             <- matrix(rmvnorm(n, mean = c(rep(0,1000)), sigma = corr_matrix_noise), n, 1000)
X_test_noise        <- matrix(rmvnorm(n_test, mean = c(rep(0,1000)), sigma = corr_matrix_noise), n_test, 1000)
} else if ((noise == TRUE) & (highdim == FALSE)) {
m_try         <- round(sqrt(30)) # number of random variables for each split
betas0        <- rep(0,15) # zero effect for additional noise variables
# create correlation matrix
corr_matrix_noise <- matrix(0, nrow = n_X, ncol = n_X)
corr_matrix_noise[1:3,1:3] <- 0.8 # correlation structure as in Janitza
corr_matrix_noise[4:6,4:6] <- 0.6
corr_matrix_noise[7:10,7:10] <- 0.4
corr_matrix_noise[11:13,11:13] <- 0.2
diag(corr_matrix_noise) <- 1
# generate X
# X_noise  <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n, n_X)
X_noise_continuous  <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n, n_X-5)
X_noise_binary      <- matrix(round(runif(5*n,0,1)), n, n_X-10)
# get together 2 matrices
X_noise             <- cbind(X_noise_continuous, X_noise_binary)
#X_test_noise        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n_test, n_X)
X_test_noise_continuous        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n_test, n_X-5)
X_test_noise_binary            <- matrix(round(runif(5*n_test,0,1)), n_test, n_X-10)
# get 2 matrices together
X_test_noise                   <- cbind(X_test_noise_continuous, X_test_noise_binary)
} else {
m_try         <- round(sqrt(15)) # number of random variables for each split
betas0        <- matrix(0,nrow=0,ncol=0) # no additional noise variables
X_noise       <- matrix(0,nrow=n,ncol=0) # empty column matrices
X_test_noise  <- matrix(0,nrow=n_test,ncol=0) # empty column matrices
}
# deterministic component of DGP
if (nonlinear == TRUE) {
deterministic         <- b0 + cbind((1)*sin(2*X)^(1), X_noise)%*%c(betas, betas0) # sin(2X)
deterministic_test    <- b0 + cbind((1)*sin(2*X_test)^(1), X_test_noise)%*%c(betas, betas0) # sin(2X)
} else {
deterministic         <- b0 + cbind(X, X_noise)%*%c(betas, betas0) # standard linear
deterministic_test    <- b0 + cbind(X_test, X_test_noise)%*%c(betas, betas0) # standard linear
}
# cutpoints for Y*
if (randomcuts == FALSE) {
cutpoints <- seq(1,Y_n-1,1)/Y_n
# ordered dependent variable (generate sample size of milion and then determine the cutpoints such that these are deterministic too and not random within the simulation)
Y_star                              <- rlogis(1000000, deterministic, 1) # unobserved continuous Y* from logistic distribution
Y_star_test                         <- rlogis(1000000*(n_test/n), deterministic_test, 1) # make it bigger as much as test set is bigger than train set
# define the true cutpoints for 3 outcomes
taus                                <- quantile(Y_star, cutpoints)
taus_test                           <- quantile(Y_star_test, cutpoints)
} else {
# make sure that the random cutpoints are at least some distance between each other
repeat{
cutpoints <- sort(runif(Y_n-1,0.09,0.91))
if(all(diff(cutpoints)>0.09)){
break
}
}
# ordered dependent variable (generate sample size of milion and then determine the cutpoints such that these are deterministic too and not random within the simulation)
Y_star                              <- rlogis(1000000, deterministic, 1) # unobserved continuous Y* from logistic distribution
Y_star_test                         <- rlogis(1000000*(n_test/n), deterministic_test, 1) # make it bigger as much as test set is bigger than train set
# define the true cutpoints for 3 outcomes
taus                                <- quantile(Y_star, cutpoints)
taus_test                           <- quantile(Y_star_test, cutpoints)
}
# real choice probabilities train
if (Y_n == 9) {
real_prob                        <- cbind(logistic(taus[1]-deterministic)-                                      0,
logistic(taus[2]-deterministic)-logistic(taus[1]-deterministic),
logistic(taus[3]-deterministic)-logistic(taus[2]-deterministic),
logistic(taus[4]-deterministic)-logistic(taus[3]-deterministic),
logistic(taus[5]-deterministic)-logistic(taus[4]-deterministic),
logistic(taus[6]-deterministic)-logistic(taus[5]-deterministic),
logistic(taus[7]-deterministic)-logistic(taus[6]-deterministic),
logistic(taus[8]-deterministic)-logistic(taus[7]-deterministic),
1                                        -logistic(taus[8]-deterministic)
)
colnames(real_prob) <- c("1","2","3","4","5","6","7","8","9")
} else if (Y_n == 6) {
real_prob                      <- cbind(logistic(taus[1]-deterministic)-                                       0,
logistic(taus[2]-deterministic)-logistic(taus[1]-deterministic),
logistic(taus[3]-deterministic)-logistic(taus[2]-deterministic),
logistic(taus[4]-deterministic)-logistic(taus[3]-deterministic),
logistic(taus[5]-deterministic)-logistic(taus[4]-deterministic),
1                                        -logistic(taus[5]-deterministic)
)
colnames(real_prob) <- c("1","2","3","4","5","6")
} else {
real_prob                       <- cbind(logistic(taus[1]-deterministic)-                                      0,
logistic(taus[2]-deterministic)-logistic(taus[1]-deterministic),
1                                        -logistic(taus[2]-deterministic)
)
colnames(real_prob) <- c("1","2","3")
}
# real choice probabilities test
if (Y_n == 9) {
real_prob_test                        <- cbind(logistic(taus_test[1]-deterministic_test)-                                      0,
logistic(taus_test[2]-deterministic_test)-logistic(taus_test[1]-deterministic_test),
logistic(taus_test[3]-deterministic_test)-logistic(taus_test[2]-deterministic_test),
logistic(taus_test[4]-deterministic_test)-logistic(taus_test[3]-deterministic_test),
logistic(taus_test[5]-deterministic_test)-logistic(taus_test[4]-deterministic_test),
logistic(taus_test[6]-deterministic_test)-logistic(taus_test[5]-deterministic_test),
logistic(taus_test[7]-deterministic_test)-logistic(taus_test[6]-deterministic_test),
logistic(taus_test[8]-deterministic_test)-logistic(taus_test[7]-deterministic_test),
1                                        -logistic(taus_test[8]-deterministic_test)
)
colnames(real_prob_test) <- c("1","2","3","4","5","6","7","8","9")
} else if (Y_n == 6) {
real_prob_test                       <- cbind(logistic(taus_test[1]-deterministic_test)-                                       0,
logistic(taus_test[2]-deterministic_test)-logistic(taus_test[1]-deterministic_test),
logistic(taus_test[3]-deterministic_test)-logistic(taus_test[2]-deterministic_test),
logistic(taus_test[4]-deterministic_test)-logistic(taus_test[3]-deterministic_test),
logistic(taus_test[5]-deterministic_test)-logistic(taus_test[4]-deterministic_test),
1                                        -logistic(taus_test[5]-deterministic_test)
)
colnames(real_prob_test) <- c("1","2","3","4","5","6")
} else {
real_prob_test                        <- cbind(logistic(taus_test[1]-deterministic_test)-                                      0,
logistic(taus_test[2]-deterministic_test)-logistic(taus_test[1]-deterministic_test),
1                                        -logistic(taus_test[2]-deterministic_test)
)
colnames(real_prob_test) <- c("1","2","3")
}
# real marginal effects train
deterministic_mean         <- b0 + cbind((1)*sin(2*matrix(colMeans(X), nrow = 1))^(1), matrix(colMeans(X_noise), nrow = 1))%*%c(betas, betas0) # sin(2X)
if (Y_n == 9) {
# initialiaze list to store results
real_me <- matrix(NA, nrow = ncol(X), ncol = 9)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_i                            <- cbind((0                                   - dlogis(taus[1] - deterministic_mean))*betas[i],
(dlogis(taus[1] - deterministic_mean) - dlogis(taus[2] - deterministic_mean))*betas[i],
(dlogis(taus[2] - deterministic_mean) - dlogis(taus[3] - deterministic_mean))*betas[i],
(dlogis(taus[3] - deterministic_mean) - dlogis(taus[4] - deterministic_mean))*betas[i],
(dlogis(taus[4] - deterministic_mean) - dlogis(taus[5] - deterministic_mean))*betas[i],
(dlogis(taus[5] - deterministic_mean) - dlogis(taus[6] - deterministic_mean))*betas[i],
(dlogis(taus[6] - deterministic_mean) - dlogis(taus[7] - deterministic_mean))*betas[i],
(dlogis(taus[7] - deterministic_mean) - dlogis(taus[8] - deterministic_mean))*betas[i],
(dlogis(taus[8] - deterministic_mean) -                                    0)*betas[i])
real_me[i,] <- real_me_i
}
colnames(real_me) <- c("1","2","3","4","5","6","7","8","9")
rownames(real_me) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me <- rbind(real_me, matrix(0, ncol = 9, nrow = ncol(X)))
} else {
real_me <- real_me
}
} else if (Y_n == 6) {
# initialiaze list to store results
real_me <- matrix(NA, nrow = ncol(X), ncol = 6)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_i                            <- cbind((0                                    - dlogis(taus[1] - deterministic_mean))*betas[i],
(dlogis(taus[1] - deterministic_mean) - dlogis(taus[2] - deterministic_mean))*betas[i],
(dlogis(taus[2] - deterministic_mean) - dlogis(taus[3] - deterministic_mean))*betas[i],
(dlogis(taus[3] - deterministic_mean) - dlogis(taus[4] - deterministic_mean))*betas[i],
(dlogis(taus[4] - deterministic_mean) - dlogis(taus[5] - deterministic_mean))*betas[i],
(dlogis(taus[5] - deterministic_mean) -                                    0)*betas[i])
real_me[i,] <- real_me_i
}
colnames(real_me) <- c("1","2","3","4","5","6")
rownames(real_me) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me <- rbind(real_me, matrix(0, ncol = 6, nrow = ncol(X)))
} else {
real_me <- real_me
}
} else {
# initialiaze list to store results
real_me <- matrix(NA, nrow = ncol(X), ncol = 3)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_i                            <- cbind((0                                    - dlogis(taus[1] - deterministic_mean))*betas[i],
(dlogis(taus[1] - deterministic_mean) - dlogis(taus[2] - deterministic_mean))*betas[i],
(dlogis(taus[2] - deterministic_mean) -                                    0)*betas[i])
real_me[i,] <- real_me_i
}
colnames(real_me) <- c("1","2","3")
rownames(real_me) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me <- rbind(real_me, matrix(0, ncol = 3, nrow = ncol(X)))
} else {
real_me <- real_me
}
}
# real marginal effects test
deterministic_mean_test         <- b0 + cbind((1)*sin(2*matrix(colMeans(X_test), nrow = 1))^(1), matrix(colMeans(X_test_noise), nrow = 1))%*%c(betas, betas0) # sin(2X)
if (Y_n == 9) {
# initialiaze list to store results
real_me_test <- matrix(NA, nrow = ncol(X_test), ncol = 9)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X_test)) {
real_me_test_i                            <- cbind((0                                   - dlogis(taus_test[1] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[1] - deterministic_mean_test) - dlogis(taus_test[2] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[2] - deterministic_mean_test) - dlogis(taus_test[3] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[3] - deterministic_mean_test) - dlogis(taus_test[4] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[4] - deterministic_mean_test) - dlogis(taus_test[5] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[5] - deterministic_mean_test) - dlogis(taus_test[6] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[6] - deterministic_mean_test) - dlogis(taus_test[7] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[7] - deterministic_mean_test) - dlogis(taus_test[8] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[8] - deterministic_mean_test) -                                    0)*betas[i])
real_me_test[i,] <- real_me_test_i
}
colnames(real_me_test) <- c("1","2","3","4","5","6","7","8","9")
rownames(real_me_test) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me_test <- rbind(real_me_test, matrix(0, ncol = 9, nrow = ncol(X)))
} else {
real_me_test <- real_me_test
}
} else if (Y_n == 6) {
# initialiaze list to store results
real_me_test <- matrix(NA, nrow = ncol(X_test), ncol = 6)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_test_i                            <- cbind((0                                    - dlogis(taus_test[1] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[1] - deterministic_mean_test) - dlogis(taus_test[2] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[2] - deterministic_mean_test) - dlogis(taus_test[3] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[3] - deterministic_mean_test) - dlogis(taus_test[4] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[4] - deterministic_mean_test) - dlogis(taus_test[5] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[5] - deterministic_mean_test) -                                    0)*betas[i])
real_me_test[i,] <- real_me_test_i
}
colnames(real_me_test) <- c("1","2","3","4","5","6")
rownames(real_me_test) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me_test <- rbind(real_me_test, matrix(0, ncol = 6, nrow = ncol(X)))
} else {
real_me_test <- real_me_test
}
} else {
# initialiaze list to store results
real_me_test <- matrix(NA, nrow = ncol(X_test), ncol = 3)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X_test)) {
real_me_test_i                            <- cbind((0                                    - dlogis(taus_test[1] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[1] - deterministic_mean_test) - dlogis(taus_test[2] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[2] - deterministic_mean_test) -                                    0)*betas[i])
real_me_test[i,] <- real_me_test_i
}
colnames(real_me_test) <- c("1","2","3")
rownames(real_me_test) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me_test <- rbind(real_me_test, matrix(0, ncol = 3, nrow = ncol(X)))
} else {
real_me_test <- real_me_test
}
}
## now simulate data using above
# simulate training data
for(i in 1:1){
# ordered dependent variable
Y_star                              <- rlogis(n, deterministic, 1) # unobserved continuous Y* from logistic distribution
# define Y
Yo                                  <- rep(NA, n) # define Y as an vector of NAs with length n
Yo[Y_star < taus[1]]                <- 1 # set Y equal to a value according to Y.star
for(j in 2:Y_n-1){
Yo[Y_star >= taus[j-1] & Y_star <= taus[j]] <- j
}
Yo[Y_star >= taus[Y_n-1]]                  <- Y_n
# ordered data
odata                               <- data.frame(Yo,cbind(X,X_noise)) # put the data in dataframe
odata$Yo                            <- as.ordered(odata$Yo)
#data_train[[i]]                     <- odata
# delete everything you do not need further
rm(Y_star, Y_star_test)
# test data
# ordered dependent variable
Y_star_test                         <- rlogis(n_test, deterministic_test, 1) # unobserved continuous Y* from logistic distribution
# define Y
Yo_test                             <- rep(NA, n_test) # define Y as an vector of NAs with length n
Yo_test[Y_star_test < taus_test[1]] <- 1 # set Y equal to a value according to Y.star
for(j in 2:Y_n-1){
Yo_test[Y_star_test >= taus_test[j-1] & Y_star_test <= taus_test[j]] <- j
}
Yo_test[Y_star_test >= taus_test[Y_n-1]]                  <- Y_n
# ordered data
odata_test                          <- data.frame(Yo_test,cbind(X_test,X_test_noise)) # put the data in dataframe
odata_test$Yo_test                  <- as.ordered(odata_test$Yo_test)
#data_test[[i]]                      <- odata_test
rm(Y_star_test)
}
## pack everything what you need
results <- list(odata, odata_test, real_prob, real_prob_test, real_me, real_me_test, taus, taus_test)
names(results) <- c("odata", "odata_test", "real_prob", "real_prob_test", "real_me", "real_me_test", "cutpoints", "cutpoints_test")
# delete everything else
rm(list=setdiff(ls(), c("results")))
# return results
return(results)
}
# general simulation settings
n             <- 1000 # sample size
n_test        <- 1000 # test sample size
# number of discrete values for Y (3,6,9)
Y_n           <- 3
# settings for different DGPs (TRUE/FALSE) - use complicated GDP now
noise             <- FALSE # additional noise variables
highdim           <- FALSE # 1000 noise (zero signal) variables
nonlinear         <- FALSE # nonlinear effects as sin(2X)*beta
multi             <- FALSE # multicollinearity of X
randomcuts        <- FALSE # equal or random cutpoints for Y*
# simulate data
sim_data <- ologit_DGP(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts)
# remove everything
rm(list=setdiff(ls(), c("sim_data")))
sim_data$real_prob
sim_data$real_me
### estimate ORF ###
library(orf)
# prepare data as matrices
X <- as.matrix(sim_data$odata[,2:ncol(sim_data$odata)])
Y <- as.matrix(sim_data$odata[,1])
# prepare data as matrices
X <- as.matrix(sim_data$odata[, 2:ncol(sim_data$odata)])
Y <- as.matrix(sim_data$odata[, 1])
colnames(Y) <- "Y"
ntree <- 1000
mtry <- 5
# estimate ORF #
orf <- orf(X,Y)
# prepare data as matrices
X <- as.matrix(sim_data$odata[, 2:ncol(sim_data$odata)])
Y <- as.matrix(as.numeric(sim_data$odata[, 1]))
colnames(Y) <- "Y"
# estimate ORF #
orf <- orf(X,Y)
summary(orf)
print(orf)
summary(orf)
summary(orf, latex = TRUE)
plot(orf)
orf_me <- margins(orf)
orf_me
sim_data$real_me
# estimate ORF #
orf <- orf(X,Y, inference = T)
print(orf)
summary(orf, latex = TRUE)
plot(orf)
orf_me <- margins(orf, infer)
orf_me <- margins(orf)
orf_me <- margins(orf)
orf_me
document()
