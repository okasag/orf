colnames(real_prob) <- c("Class 1", "Class 2", "Class 3")
# 1. estimate ordered forest
set.seed(123)
orf_fit <- orf(X,Y)
# predict ordered probabilities
orf_pred <- predict(orf_fit)$predictions
# compute MSE (in-sample)
orf_mse <- mean((rowSums((real_prob - orf_pred)^2)/3))
# 2. estimate ordered logit
ologit_fit <- polr(as.factor(Y) ~ .,  data = as.data.frame(cbind(Y,X)))
# predict ordered probabilities
ologit_pred <- predict(ologit_fit, type = "probs")
# compute MSE (in-sample)
ologit_mse <- mean((rowSums((real_prob - ologit_pred)^2)/3))
# compute true marginal effects
# X1 continuous (marginal change)
real_me_x1 <- cbind((0                                               - dlogis(cuts[2] - cbind(X1, X2, X3, X4)%*%betas))*betas[1],
(dlogis(cuts[2] - cbind(X1, X2, X3, X4)%*%betas) - dlogis(cuts[3] - cbind(X1, X2, X3, X4)%*%betas))*betas[1],
(dlogis(cuts[3] - cbind(X1, X2, X3, X4)%*%betas) -                                               0)*betas[1])
# take the mean
real_me_x1 <- colMeans(real_me_x1)
# X2 categorical (discrete change)
real_me_x2 <- (cbind(logistic(cuts[2] - cbind(X1, ceiling(mean(X2)), X3, X4)%*%betas) - 0,
logistic(cuts[3] - cbind(X1, ceiling(mean(X2)), X3, X4)%*%betas) - logistic(cuts[2]-cbind(X1, ceiling(mean(X2)), X3, X4)%*%betas),
1 - logistic(cuts[3]-cbind(X1, ceiling(mean(X2)), X3, X4)%*%betas))
-
cbind(logistic(cuts[2] - cbind(X1, floor(mean(X2)), X3, X4)%*%betas) - 0,
logistic(cuts[3] - cbind(X1, floor(mean(X2)), X3, X4)%*%betas) - logistic(cuts[2]-cbind(X1, floor(mean(X2)), X3, X4)%*%betas),
1 - logistic(cuts[3]-cbind(X1, floor(mean(X2)), X3, X4)%*%betas)))
# take the mean
real_me_x2 <- colMeans(real_me_x2)
# X3 binary (discrete change)
real_me_x3 <- (cbind(logistic(cuts[2] - cbind(X1, X2, 1, X4)%*%betas) - 0,
logistic(cuts[3] - cbind(X1, X2, 1, X4)%*%betas) - logistic(cuts[2]-cbind(X1, X2, 1, X4)%*%betas),
1 - logistic(cuts[3]-cbind(X1, X2, 1, X4)%*%betas))
-
cbind(logistic(cuts[2] - cbind(X1, X2, 0, X4)%*%betas) - 0,
logistic(cuts[3] - cbind(X1, X2, 0, X4)%*%betas) - logistic(cuts[2]-cbind(X1, X2, 0, X4)%*%betas),
1 - logistic(cuts[3]-cbind(X1, X2, 0, X4)%*%betas)))
# take the mean
real_me_x3 <- colMeans(real_me_x3)
# combine everything together
real_me <- rbind(real_me_x1, real_me_x2, real_me_x3, rep(0,3))
colnames(real_me) <- c("Class 1", "Class 2", "Class 3")
rownames(real_me) <- c("X1", "X2", "X3", "X4")
# 1. estimate orf marginal effects
orf_me <- margins(orf_fit)
# 2. estimate ologit marginal effects
ologit_me <- ocME(ologit_fit)$out
# compare the three
round(real_me, 4)
round(orf_me$effects, 4)
ologit_me$ME.all
# check mse for marginal effects
orf_me_mse <- mean((rowSums((real_me - orf_me$effects)^2)/3))
ologit_me_mse <- mean((rowSums((real_me - ologit_me$ME.all)^2)/3))
X2 <- rbinom(n, 2, 1/3)
X2
hist(X2)
X2 <- rbinom(n, 2, 2/3)
hist(X2)
X2 <- rbinom(n, 2, 1/3)
X2 <- rbinom(n, 2, 1/2)
hist(X2)
X2 <- rbinom(n, 3, 1/3)
hist(X2)
X2 <- rbinom(n, 3, 1/2)
hist(X2)
install.packages("grf")
library(grf)
require(ranger)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
require(orf)
data(odata)
Y <- odata[, 1]
X <- odata[, -1]
class(Y)
class(X)
library(devtools)
document()
check()
library(orf)
document()
check()
document()
check()
library(orf)
margins(p)
p <- 1
margins(p)
margins(orf_fit)
document()
check()
document()
check()
document()
check()
library(orf)
document()
check()
library(orf)
document()
check()
library(orf)
document()
document()
check()
library(orf)
document()
check()
licence()
document()
check()
library(orf)
rep(1:3, each = 5)
rep(1:3, 5)
rep(1:3, 5)
rep(1:3, each = 5)
matrix(rep(1:3, each = 5), nrow = 5)
matrix(rep(1:3, 5), nrow = 5)
matrix(rep(1:3, 5))
matrix(rep(1:3, 5), ncol = 5)
matrix(rep(1:3, 5), ncol = 3)
matrix(rep(1:3, each = 5), nrow = 5)
matrix(rep(1:3, times = 5,  each = 5), nrow = 5)
matrix(rep(1:3, times = 5,  each = 5))
matrix(rep(1:3, times = 5))
(rep(1:3, times = 5))
matrix(rep(1:3, times = 5)), nrow = 5)
matrix(rep(1:3, times = 5), nrow = 5)
matrix(rep(1:3, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
library(devtools)
document()
check()
document()
document()
check()
library(orf)
library(orf)
## Ordered Forest
require(orf)
# load example data
data(odata)
# specify response and covariates
Y <- as.numeric(odata[, 1])
X <- as.matrix(odata[, -1])
# estimate Ordered Forest with default parameters
orf <- orf(X, Y)
margins(orf)
library(orf)
set.seed(1)
orf <- orf(X, Y)
margins(orf)
margins(orf)
View(X_sd)
library(orf)
set.seed(1)
orf <- orf(X, Y)
margins(orf)
View(X_sd)
library(orf)
predictions <- orf$predictions
observed <- Y
observed
rankProbScore <- function(predictions, observed){
ncat <- ncol(predictions)
npred <- nrow(predictions)
rps <- numeric(npred)
for (rr in 1:npred){
obsvec <- rep(0, ncat)
obsvec[observed[rr]] <- 1
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr,1:i]) - sum(obsvec[1:i]))^2
}
rps[rr] <- (1/(ncat-1))*cumulative
}
return(rps)
}
#' Computes the mean ranked probability score (RPS) for evaluating the accuracy of
#' ordered probability predictions
#'
#' @param predictions matrix of predictions (n x categories)
#' @param observed vector of observed ordered categorical outcomes (n x 1)
#'
#' @return scalar, mean RPS for given predictions
#'
#' @keywords internal
#'
rps <- function(predictions, observed){
# ------------------------------------------------------------------------------------ #
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# ------------------------------------------------------------------------------------ #
# prepare 0 vector for rps
rps <- numeric(npred)
# compute the rps (thanks to: https://opisthokonta.net/?p=1333)
for (rr in 1:npred){
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr, 1:i]) - sum(observed_dist[rr, 1:i]))^2
}
rps[rr] <- (1/(ncat - 1))*cumulative
}
# take mean of rps
mrps <- mean(rps)
# ------------------------------------------------------------------------------------ #
# return the mrps
return(mrps)
# ------------------------------------------------------------------------------------ #
}
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
ncat <- ncol(predictions)
npred <- nrow(predictions)
rps <- numeric(npred)
# prepare 0 vector for rps
rps <- numeric(npred)
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
View(observed_dist)
# compute the rps (thanks to: https://opisthokonta.net/?p=1333)
for (rr in 1:npred){
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr, 1:i]) - sum(observed_dist[rr, 1:i]))^2
}
rps[rr] <- (1/(ncat - 1))*cumulative
}
rps
# take mean of rps
mrps <- mean(rps)
mrps
obsvec <- rep(0, ncat)
obsvec
obsvec[observed[rr]] <- 1
obsvec
rankProbScore(predictions, observed)
mean(rankProbScore(predictions, observed))
rps(predictions, observed)
#' Computes the mean ranked probability score (RPS) for evaluating the accuracy of
#' ordered probability predictions
#'
#' @param predictions matrix of predictions (n x categories)
#' @param observed vector of observed ordered categorical outcomes (n x 1)
#'
#' @return scalar, mean RPS for given predictions
#'
#' @keywords internal
#'
rps <- function(predictions, observed){
# ------------------------------------------------------------------------------------ #
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# ------------------------------------------------------------------------------------ #
# prepare 0 vector for rps
rps <- numeric(npred)
# compute the rps (thanks to: https://opisthokonta.net/?p=1333)
for (rr in 1:npred){
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr, 1:i]) - sum(observed_dist[rr, 1:i]))^2
}
rps[rr] <- (1/(ncat - 1))*cumulative
}
# take mean of rps
mrps <- mean(rps)
# ------------------------------------------------------------------------------------ #
# return the mrps
return(mrps)
# ------------------------------------------------------------------------------------ #
}
rps(predictions, observed)
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# prepare 0 vector for rps
rps <- numeric(npred)
cumulative <- 0
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[, 1:i]) - sum(observed_dist[, 1:i]))^2
}
cumulative
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[, 1:i]) - sum(observed_dist[, 1:i]))^2
}
cumulative
cumulative <- numeric(npred)
cumulative
i
i=1
cumulative
sum(predictions[, 1:i])
predictions[, 1:i]
rowSums(predictions[, 1:i])
(matrix(predictions[, 1:i])
)
rowSums(matrix(predictions[, 1:i]))
rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i]))
(rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
cumulative
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
cumulative
(1/(ncat - 1))*cumulative
rps
cumulative <- numeric(npred)
i
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
cumulative
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
}
observed_dist
predictions
i
predictions[, 1:i]
matrix(predictions[, 1:i])
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i], ncol = i)) - rowSums(matrix(observed_dist[, 1:i], ncol = i)))^2
}
cumulative
rps <- (1/(ncat - 1))*cumulative
rps
mean(rps)
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# prepare 0 vector for rps
rps <- numeric(npred)
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i], ncol = i)) - rowSums(matrix(observed_dist[, 1:i], ncol = i)))^2
}
rps <- (1/(ncat - 1))*cumulative
mean(rps)
rankProbScore(predictions, observed)
mean(rankProbScore(predictions, observed))
rps
all.equal(rps, rankProbScore(predictions, observed))
repeat_row(apply(X, 2, sd), ntimes = X_rows)
#' repeat rows of a matrix
#'
#' function for replicating rows of a matrix n number of times
#'
#' @param matrix matrix which rows should be replicated
#' @param ntimes number of times to repeat
#'
#' @keywords internal
#'
repeat_row <- function(matrix, ntimes){
# inspired by and thanks to: https://www.r-bloggers.com/a-quick-way-to-do-row-repeat-and-col-repeat-rep-row-rep-col/
matrix(rep(matrix, times = 1, each = ntimes), nrow = ntimes)
}
repeat_row(apply(X, 2, sd), ntimes = X_rows)
X_rows <- nrow(X)
repeat_row(apply(X, 2, sd), ntimes = X_rows)
matrix(rep(apply(X, 2, sd), times = 1, each = X_rows), nrow = X_rows)
document()
check()
library(orf)
check()
document()
check()
document()
check()
library(orf)
document()
check()
library(orf)
document()
check()
library(orf)
packageDescription()
packageDescription(grf)
packageDescription("grf")
packageDescription("orf")
packageDescription("devtools")
packageDescription("orf")
packageDescription("devtools")
packageDescription("grf")
document()
check()
document()
check()
library(orf)
library(ranger)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
set.seed(1, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
set.seed(2, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
set.seed(10, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
set.seed(123, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
library(grf)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
r.forest <- regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
set.seed(123)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rejection")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
r <- regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
r <- regression_forest(X, Y)
r
summary(r)
r$debiased.error
sessionInfo()
RNGkind()
