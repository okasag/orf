forest_pred
lapply(forest_pred, function(x) { rownames(x) <- (1:n_fulldata) })
lapply(forest_pred, function(x) { rownames(x) <- (1:n_fulldata); return(x) })
kktko <- lapply(forest_pred, function(x) { rownames(x) <- (1:n_fulldata); return(x) })
kktko
forest_pred
kktko
kktko[[1]]
kktko[[1]][1:10]
kktko[[1]][1:10,1]
honest_pred
honest_pred
# take care of rownames
forest_pred <- lapply(forest_pred, function(x) { rownames(x) <- (1:n_fulldata); return(x) })
# predictions (vectors as matrices)
honest_pred_kkt <- lapply(forest_pred, function(x) matrix(x[(1:n_halfdata), ], ncol = 1))
train_pred_kkt  <- lapply(forest_pred, function(x) matrix(x[((n_halfdata + 1):n_fulldata), ], ncol = 1))
# weights (matrices)
honest_weights_pred_kkt <- lapply(forest_weights_pred, function(x) x[(1:n_halfdata), ])
train_weights_pred_kkt  <- lapply(forest_weights_pred, function(x) x[((n_halfdata + 1):n_fulldata), ])
var_final_kkt <- get_orf_variance(honest_pred_kkt, honest_weights_pred_kkt, train_pred_kkt, train_weights_pred_kkt, Y_ind_honest)
var_final_kkt
honest_pred_kkt
train_pred_kkt
honest_pred_kkt
train_pred_kkt
forest_pred
# predictions (vectors as matrices)
honest_pred_kkt <- lapply(forest_pred, function(x) x[(1:n_halfdata), ], ncol = 1)
# predictions (vectors as matrices)
honest_pred_kkt <- lapply(forest_pred, function(x) x[(1:n_halfdata), ])
train_pred_kkt  <- lapply(forest_pred, function(x) x[((n_halfdata + 1):n_fulldata), ])
honest_pred_kkt
# predictions (vectors as matrices)
honest_pred_kkt <- lapply(forest_pred, function(x) as.matrix(x[(1:n_halfdata), ]))
honest_pred_kkt
train_pred_kkt  <- lapply(forest_pred, function(x) as.matrix(x[((n_halfdata + 1):n_fulldata), ]))
train_pred_kkt
# weights (matrices)
honest_weights_pred_kkt <- lapply(forest_weights_pred, function(x) x[(1:n_halfdata), ])
train_weights_pred_kkt  <- lapply(forest_weights_pred, function(x) x[((n_halfdata + 1):n_fulldata), ])
var_final_kkt <- get_orf_variance(honest_pred_kkt, honest_weights_pred_kkt, train_pred_kkt, train_weights_pred_kkt, Y_ind_honest)
var_final_kkt
# compute the variances for the categorical predictions
var_final <- pred_orf_variance(forest_pred, forest_weights_pred, Y_ind_honest)
var_final
var_final_kkt
var_final
var_final_kkt
document()
check()
library(orf)
### ordered logit model DGP
## built a function for ologit DGP
ologit_DGP <- function(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts) {
# set seed
set.seed(3192) # put your birthday here
# number of covariates
n_X           <- 15 # covariates (only 15 fixed so far)
# intercept
b0            <- 0 # true value for the intercept always 0 for ordered model
# effects
betas         <- c(rep(1,5),rep(0.75,5),rep(0.5,5))
# generate covariates
if (multi == TRUE) {
# define possible levels of correlation for Xs
corr_level <- 0.8
# create correlation matrix
corr_matrix <- matrix(0, nrow = n_X, ncol = n_X)
corr_matrix[c(1,3,5,7,9,11,13,15),c(1,3,5,7,9,11,13,15)] <- corr_level # correlation structure as in Janitza
#corr_matrix[,c(1,3,6,8,11,13)] <- corr_level # correlation structure as in Janitza
diag(corr_matrix) <- 1
# generate X
X             <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix), n, n_X)
X_test        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix), n_test, n_X)
} else {
# define possible levels of correlation for Xs
corr_level <- 0
# create correlation matrix
corr_matrix <- matrix(0, nrow = n_X, ncol = n_X)
diag(corr_matrix) <- 1
# generate X
X             <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix), n, n_X)
X_test        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix), n_test, n_X)
}
# noise variables + high dimensional setting
if ((noise == TRUE) & (highdim == TRUE)) {
m_try         <- round(sqrt(1015)) # number of random variables for each split
betas0        <- rep(0,1000) # zero effect for additional noise variables
# create correlation matrix
corr_matrix_noise <- matrix(0, nrow = 1000, ncol = 1000)
corr_matrix_noise[1:3,1:3] <- 0.8 # correlation structure as in Janitza
corr_matrix_noise[4:6,4:6] <- 0.6
corr_matrix_noise[7:10,7:10] <- 0.4
corr_matrix_noise[11:13,11:13] <- 0.2
diag(corr_matrix_noise) <- 1
# generate X
X_noise             <- matrix(rmvnorm(n, mean = c(rep(0,1000)), sigma = corr_matrix_noise), n, 1000)
X_test_noise        <- matrix(rmvnorm(n_test, mean = c(rep(0,1000)), sigma = corr_matrix_noise), n_test, 1000)
} else if ((noise == TRUE) & (highdim == FALSE)) {
m_try         <- round(sqrt(30)) # number of random variables for each split
betas0        <- rep(0,15) # zero effect for additional noise variables
# create correlation matrix
corr_matrix_noise <- matrix(0, nrow = n_X, ncol = n_X)
corr_matrix_noise[1:3,1:3] <- 0.8 # correlation structure as in Janitza
corr_matrix_noise[4:6,4:6] <- 0.6
corr_matrix_noise[7:10,7:10] <- 0.4
corr_matrix_noise[11:13,11:13] <- 0.2
diag(corr_matrix_noise) <- 1
# generate X
# X_noise  <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n, n_X)
X_noise_continuous  <- matrix(rmvnorm(n, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n, n_X-5)
X_noise_binary      <- matrix(round(runif(5*n,0,1)), n, n_X-10)
# get together 2 matrices
X_noise             <- cbind(X_noise_continuous, X_noise_binary)
#X_test_noise        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n_test, n_X)
X_test_noise_continuous        <- matrix(rmvnorm(n_test, mean = c(rep(0,n_X)), sigma = corr_matrix_noise), n_test, n_X-5)
X_test_noise_binary            <- matrix(round(runif(5*n_test,0,1)), n_test, n_X-10)
# get 2 matrices together
X_test_noise                   <- cbind(X_test_noise_continuous, X_test_noise_binary)
} else {
m_try         <- round(sqrt(15)) # number of random variables for each split
betas0        <- matrix(0,nrow=0,ncol=0) # no additional noise variables
X_noise       <- matrix(0,nrow=n,ncol=0) # empty column matrices
X_test_noise  <- matrix(0,nrow=n_test,ncol=0) # empty column matrices
}
# deterministic component of DGP
if (nonlinear == TRUE) {
deterministic         <- b0 + cbind((1)*sin(2*X)^(1), X_noise)%*%c(betas, betas0) # sin(2X)
deterministic_test    <- b0 + cbind((1)*sin(2*X_test)^(1), X_test_noise)%*%c(betas, betas0) # sin(2X)
} else {
deterministic         <- b0 + cbind(X, X_noise)%*%c(betas, betas0) # standard linear
deterministic_test    <- b0 + cbind(X_test, X_test_noise)%*%c(betas, betas0) # standard linear
}
# cutpoints for Y*
if (randomcuts == FALSE) {
cutpoints <- seq(1,Y_n-1,1)/Y_n
# ordered dependent variable (generate sample size of milion and then determine the cutpoints such that these are deterministic too and not random within the simulation)
Y_star                              <- rlogis(1000000, deterministic, 1) # unobserved continuous Y* from logistic distribution
Y_star_test                         <- rlogis(1000000*(n_test/n), deterministic_test, 1) # make it bigger as much as test set is bigger than train set
# define the true cutpoints for 3 outcomes
taus                                <- quantile(Y_star, cutpoints)
taus_test                           <- quantile(Y_star_test, cutpoints)
} else {
# make sure that the random cutpoints are at least some distance between each other
repeat{
cutpoints <- sort(runif(Y_n-1,0.09,0.91))
if(all(diff(cutpoints)>0.09)){
break
}
}
# ordered dependent variable (generate sample size of milion and then determine the cutpoints such that these are deterministic too and not random within the simulation)
Y_star                              <- rlogis(1000000, deterministic, 1) # unobserved continuous Y* from logistic distribution
Y_star_test                         <- rlogis(1000000*(n_test/n), deterministic_test, 1) # make it bigger as much as test set is bigger than train set
# define the true cutpoints for 3 outcomes
taus                                <- quantile(Y_star, cutpoints)
taus_test                           <- quantile(Y_star_test, cutpoints)
}
# real choice probabilities train
if (Y_n == 9) {
real_prob                        <- cbind(logistic(taus[1]-deterministic)-                                      0,
logistic(taus[2]-deterministic)-logistic(taus[1]-deterministic),
logistic(taus[3]-deterministic)-logistic(taus[2]-deterministic),
logistic(taus[4]-deterministic)-logistic(taus[3]-deterministic),
logistic(taus[5]-deterministic)-logistic(taus[4]-deterministic),
logistic(taus[6]-deterministic)-logistic(taus[5]-deterministic),
logistic(taus[7]-deterministic)-logistic(taus[6]-deterministic),
logistic(taus[8]-deterministic)-logistic(taus[7]-deterministic),
1                                        -logistic(taus[8]-deterministic)
)
colnames(real_prob) <- c("1","2","3","4","5","6","7","8","9")
} else if (Y_n == 6) {
real_prob                      <- cbind(logistic(taus[1]-deterministic)-                                       0,
logistic(taus[2]-deterministic)-logistic(taus[1]-deterministic),
logistic(taus[3]-deterministic)-logistic(taus[2]-deterministic),
logistic(taus[4]-deterministic)-logistic(taus[3]-deterministic),
logistic(taus[5]-deterministic)-logistic(taus[4]-deterministic),
1                                        -logistic(taus[5]-deterministic)
)
colnames(real_prob) <- c("1","2","3","4","5","6")
} else {
real_prob                       <- cbind(logistic(taus[1]-deterministic)-                                      0,
logistic(taus[2]-deterministic)-logistic(taus[1]-deterministic),
1                                        -logistic(taus[2]-deterministic)
)
colnames(real_prob) <- c("1","2","3")
}
# real choice probabilities test
if (Y_n == 9) {
real_prob_test                        <- cbind(logistic(taus_test[1]-deterministic_test)-                                      0,
logistic(taus_test[2]-deterministic_test)-logistic(taus_test[1]-deterministic_test),
logistic(taus_test[3]-deterministic_test)-logistic(taus_test[2]-deterministic_test),
logistic(taus_test[4]-deterministic_test)-logistic(taus_test[3]-deterministic_test),
logistic(taus_test[5]-deterministic_test)-logistic(taus_test[4]-deterministic_test),
logistic(taus_test[6]-deterministic_test)-logistic(taus_test[5]-deterministic_test),
logistic(taus_test[7]-deterministic_test)-logistic(taus_test[6]-deterministic_test),
logistic(taus_test[8]-deterministic_test)-logistic(taus_test[7]-deterministic_test),
1                                        -logistic(taus_test[8]-deterministic_test)
)
colnames(real_prob_test) <- c("1","2","3","4","5","6","7","8","9")
} else if (Y_n == 6) {
real_prob_test                       <- cbind(logistic(taus_test[1]-deterministic_test)-                                       0,
logistic(taus_test[2]-deterministic_test)-logistic(taus_test[1]-deterministic_test),
logistic(taus_test[3]-deterministic_test)-logistic(taus_test[2]-deterministic_test),
logistic(taus_test[4]-deterministic_test)-logistic(taus_test[3]-deterministic_test),
logistic(taus_test[5]-deterministic_test)-logistic(taus_test[4]-deterministic_test),
1                                        -logistic(taus_test[5]-deterministic_test)
)
colnames(real_prob_test) <- c("1","2","3","4","5","6")
} else {
real_prob_test                        <- cbind(logistic(taus_test[1]-deterministic_test)-                                      0,
logistic(taus_test[2]-deterministic_test)-logistic(taus_test[1]-deterministic_test),
1                                        -logistic(taus_test[2]-deterministic_test)
)
colnames(real_prob_test) <- c("1","2","3")
}
# real marginal effects train
deterministic_mean         <- b0 + cbind((1)*sin(2*matrix(colMeans(X), nrow = 1))^(1), matrix(colMeans(X_noise), nrow = 1))%*%c(betas, betas0) # sin(2X)
if (Y_n == 9) {
# initialiaze list to store results
real_me <- matrix(NA, nrow = ncol(X), ncol = 9)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_i                            <- cbind((0                                   - dlogis(taus[1] - deterministic_mean))*betas[i],
(dlogis(taus[1] - deterministic_mean) - dlogis(taus[2] - deterministic_mean))*betas[i],
(dlogis(taus[2] - deterministic_mean) - dlogis(taus[3] - deterministic_mean))*betas[i],
(dlogis(taus[3] - deterministic_mean) - dlogis(taus[4] - deterministic_mean))*betas[i],
(dlogis(taus[4] - deterministic_mean) - dlogis(taus[5] - deterministic_mean))*betas[i],
(dlogis(taus[5] - deterministic_mean) - dlogis(taus[6] - deterministic_mean))*betas[i],
(dlogis(taus[6] - deterministic_mean) - dlogis(taus[7] - deterministic_mean))*betas[i],
(dlogis(taus[7] - deterministic_mean) - dlogis(taus[8] - deterministic_mean))*betas[i],
(dlogis(taus[8] - deterministic_mean) -                                    0)*betas[i])
real_me[i,] <- real_me_i
}
colnames(real_me) <- c("1","2","3","4","5","6","7","8","9")
rownames(real_me) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me <- rbind(real_me, matrix(0, ncol = 9, nrow = ncol(X)))
} else {
real_me <- real_me
}
} else if (Y_n == 6) {
# initialiaze list to store results
real_me <- matrix(NA, nrow = ncol(X), ncol = 6)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_i                            <- cbind((0                                    - dlogis(taus[1] - deterministic_mean))*betas[i],
(dlogis(taus[1] - deterministic_mean) - dlogis(taus[2] - deterministic_mean))*betas[i],
(dlogis(taus[2] - deterministic_mean) - dlogis(taus[3] - deterministic_mean))*betas[i],
(dlogis(taus[3] - deterministic_mean) - dlogis(taus[4] - deterministic_mean))*betas[i],
(dlogis(taus[4] - deterministic_mean) - dlogis(taus[5] - deterministic_mean))*betas[i],
(dlogis(taus[5] - deterministic_mean) -                                    0)*betas[i])
real_me[i,] <- real_me_i
}
colnames(real_me) <- c("1","2","3","4","5","6")
rownames(real_me) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me <- rbind(real_me, matrix(0, ncol = 6, nrow = ncol(X)))
} else {
real_me <- real_me
}
} else {
# initialiaze list to store results
real_me <- matrix(NA, nrow = ncol(X), ncol = 3)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_i                            <- cbind((0                                    - dlogis(taus[1] - deterministic_mean))*betas[i],
(dlogis(taus[1] - deterministic_mean) - dlogis(taus[2] - deterministic_mean))*betas[i],
(dlogis(taus[2] - deterministic_mean) -                                    0)*betas[i])
real_me[i,] <- real_me_i
}
colnames(real_me) <- c("1","2","3")
rownames(real_me) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me <- rbind(real_me, matrix(0, ncol = 3, nrow = ncol(X)))
} else {
real_me <- real_me
}
}
# real marginal effects test
deterministic_mean_test         <- b0 + cbind((1)*sin(2*matrix(colMeans(X_test), nrow = 1))^(1), matrix(colMeans(X_test_noise), nrow = 1))%*%c(betas, betas0) # sin(2X)
if (Y_n == 9) {
# initialiaze list to store results
real_me_test <- matrix(NA, nrow = ncol(X_test), ncol = 9)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X_test)) {
real_me_test_i                            <- cbind((0                                   - dlogis(taus_test[1] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[1] - deterministic_mean_test) - dlogis(taus_test[2] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[2] - deterministic_mean_test) - dlogis(taus_test[3] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[3] - deterministic_mean_test) - dlogis(taus_test[4] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[4] - deterministic_mean_test) - dlogis(taus_test[5] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[5] - deterministic_mean_test) - dlogis(taus_test[6] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[6] - deterministic_mean_test) - dlogis(taus_test[7] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[7] - deterministic_mean_test) - dlogis(taus_test[8] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[8] - deterministic_mean_test) -                                    0)*betas[i])
real_me_test[i,] <- real_me_test_i
}
colnames(real_me_test) <- c("1","2","3","4","5","6","7","8","9")
rownames(real_me_test) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me_test <- rbind(real_me_test, matrix(0, ncol = 9, nrow = ncol(X)))
} else {
real_me_test <- real_me_test
}
} else if (Y_n == 6) {
# initialiaze list to store results
real_me_test <- matrix(NA, nrow = ncol(X_test), ncol = 6)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X)) {
real_me_test_i                            <- cbind((0                                    - dlogis(taus_test[1] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[1] - deterministic_mean_test) - dlogis(taus_test[2] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[2] - deterministic_mean_test) - dlogis(taus_test[3] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[3] - deterministic_mean_test) - dlogis(taus_test[4] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[4] - deterministic_mean_test) - dlogis(taus_test[5] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[5] - deterministic_mean_test) -                                    0)*betas[i])
real_me_test[i,] <- real_me_test_i
}
colnames(real_me_test) <- c("1","2","3","4","5","6")
rownames(real_me_test) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me_test <- rbind(real_me_test, matrix(0, ncol = 6, nrow = ncol(X)))
} else {
real_me_test <- real_me_test
}
} else {
# initialiaze list to store results
real_me_test <- matrix(NA, nrow = ncol(X_test), ncol = 3)
# loop over betas (only positive ones, noise variables result in zero me)
for(i in 1:ncol(X_test)) {
real_me_test_i                            <- cbind((0                                    - dlogis(taus_test[1] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[1] - deterministic_mean_test) - dlogis(taus_test[2] - deterministic_mean_test))*betas[i],
(dlogis(taus_test[2] - deterministic_mean_test) -                                    0)*betas[i])
real_me_test[i,] <- real_me_test_i
}
colnames(real_me_test) <- c("1","2","3")
rownames(real_me_test) <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X11","X12","X13","X14","X15")
# take care of zero coefficients
if (noise == TRUE) {
real_me_test <- rbind(real_me_test, matrix(0, ncol = 3, nrow = ncol(X)))
} else {
real_me_test <- real_me_test
}
}
## now simulate data using above
# simulate training data
for(i in 1:1){
# ordered dependent variable
Y_star                              <- rlogis(n, deterministic, 1) # unobserved continuous Y* from logistic distribution
# define Y
Yo                                  <- rep(NA, n) # define Y as an vector of NAs with length n
Yo[Y_star < taus[1]]                <- 1 # set Y equal to a value according to Y.star
for(j in 2:Y_n-1){
Yo[Y_star >= taus[j-1] & Y_star <= taus[j]] <- j
}
Yo[Y_star >= taus[Y_n-1]]                  <- Y_n
# ordered data
odata                               <- data.frame(Yo,cbind(X,X_noise)) # put the data in dataframe
odata$Yo                            <- as.ordered(odata$Yo)
#data_train[[i]]                     <- odata
# delete everything you do not need further
rm(Y_star, Y_star_test)
# test data
# ordered dependent variable
Y_star_test                         <- rlogis(n_test, deterministic_test, 1) # unobserved continuous Y* from logistic distribution
# define Y
Yo_test                             <- rep(NA, n_test) # define Y as an vector of NAs with length n
Yo_test[Y_star_test < taus_test[1]] <- 1 # set Y equal to a value according to Y.star
for(j in 2:Y_n-1){
Yo_test[Y_star_test >= taus_test[j-1] & Y_star_test <= taus_test[j]] <- j
}
Yo_test[Y_star_test >= taus_test[Y_n-1]]                  <- Y_n
# ordered data
odata_test                          <- data.frame(Yo_test,cbind(X_test,X_test_noise)) # put the data in dataframe
odata_test$Yo_test                  <- as.ordered(odata_test$Yo_test)
#data_test[[i]]                      <- odata_test
rm(Y_star_test)
}
## pack everything what you need
results <- list(odata, odata_test, real_prob, real_prob_test, real_me, real_me_test, taus, taus_test)
names(results) <- c("odata", "odata_test", "real_prob", "real_prob_test", "real_me", "real_me_test", "cutpoints", "cutpoints_test")
# delete everything else
rm(list=setdiff(ls(), c("results")))
# return results
return(results)
}
# general simulation settings
n             <- 1000 # sample size
n_test        <- 1000 # test sample size
# number of discrete values for Y (3,6,9)
Y_n           <- 3
# settings for different DGPs (TRUE/FALSE) - use complicated GDP now
noise             <- TRUE # additional noise variables
highdim           <- FALSE # 1000 noise (zero signal) variables
nonlinear         <- TRUE # nonlinear effects as sin(2X)*beta
multi             <- TRUE # multicollinearity of X
randomcuts        <- FALSE # equal or random cutpoints for Y*
# simulate data
sim_data <- ologit_DGP(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts)
# remove everything
rm(list=setdiff(ls(), c("sim_data")))
### estimate standard ologit ###
library(MASS)
library(erer)
# try out ologit
ologit <- polr(Yo ~ ., data = sim_data$odata, Hess = TRUE)
# marginal effects for logit
ologit_me <-ocME(ologit)$out$ME.all
### estimate ORF ###
library(orf)
# prepare data as matrices
X <- as.matrix(sim_data$odata[, 2:ncol(sim_data$odata)])
Y <- as.matrix(as.numeric(sim_data$odata[, 1]))
colnames(Y) <- "Y"
# check new predict functionality
set.seed(1)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = T)
orf_inf_pred <- predict(orf_inf, inference = T)
all.equal(orf_inf$forestPredictions, orf_inf_pred$forestPredictions)
all.equal(orf_inf$forestVariances, orf_inf_pred$forestVariances)
kktko_var <- orf_inf$forestVariances
kktko_pred <- orf_inf$forestPredictions
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = T)
View(honest_multi_demeaned)
View(honest_multi)
View(train_pred)
View(honest_pred)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
View(honest_multi)
View(honest_pred)
View(train_multi)
View(train_pred)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
View(honest_multi_demeaned)
honest_multi_demeaned
honest_multi_demeaned[[1]][[1]]
ncol(honest_multi_demeaned[[1]][[1]])
nrow(honest_multi_demeaned[[1]][[1]])
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = T)
View(honest_multi_demeaned)
honest_multi_demeaned[[1]][[1]]
nrow(honest_multi_demeaned[[1]][[1]])
ncol(honest_multi_demeaned[[1]][[1]])
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
# check new predict functionality
set.seed(1)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
document()
check()
library(orf)
# check new predict functionality
set.seed(1)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
orf_inf_pred <- predict(orf_inf, inference = T)
honest_pred
train_pred
honest_weights
train_weights
Y_ind_honest
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = T)
honest_pred
honest_weights
train_pred
train_weights
Y_ind_honest
document()
check()
library(orf)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
Y_ind_honest
document()
check()
library(orf)
# check new predict functionality
set.seed(1)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = F)
orf_inf_pred <- predict(orf_inf, inference = T)
all.equal(orf_inf$forestPredictions, orf_inf_pred$forestPredictions)
all.equal(orf_inf$forestVariances, orf_inf_pred$forestVariances)
orf_inf$forestPredictions
orf_inf_pred$forestPredictions
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = T)
# check new predict functionality
set.seed(1)
orf_inf <- orf(X,Y, honesty = T, replace = F, inference = T)
all.equal(orf_inf$forestVariances, orf_inf_pred$forestVariances)
all.equal(orf_inf$forestPredictions, orf_inf_pred$forestPredictions)
all.equal(orf_inf$forestVariances, orf_inf_pred$forestVariances)
orf_inf$forestVariances
orf_inf_pred$forestVariances
orf_inf_pred <- predict(orf_inf, inference = T)
all.equal(orf_inf$forestPredictions, orf_inf_pred$forestPredictions)
all.equal(orf_inf$forestVariances, orf_inf_pred$forestVariances)
orf_inf_pred <- predict(orf_inf, inference = F)
all.equal(orf_inf$forestPredictions, orf_inf_pred$forestPredictions)
all.equal(orf_inf$forestVariances, orf_inf_pred$forestVariances)
orf_inf$forestVariances
orf_inf_pred$forestVariances
