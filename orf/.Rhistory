honest <- data[honesty_i, ]
if(all(sort(unique(train[, 1])) == sort(unique(honest[, 1])))){
break
}
}
repeat{
# randomize indices for train and honest sample (take care of uneven numbers with floor and ceiling)
ind <- sample(c(rep(0, ceiling((1-honesty.fraction)*n)), rep(1, floor(honesty.fraction*n))))
# indicator for which observations go into train and honest set
honesty_i <- which(ind == 1)
# separate training set
train <- data[-honesty_i, ]
# separate honest set
honest <- data[honesty_i, ]
if(all(sort(unique(train[, 1])) == sort(unique(honest[, 1])))){
break
}
}
repeat{
# randomize indices for train and honest sample (take care of uneven numbers with floor and ceiling)
ind <- sample(c(rep(0, ceiling((1-honesty.fraction)*n)), rep(1, floor(honesty.fraction*n))))
# indicator for which observations go into train and honest set
honesty_i <- which(ind == 1)
# separate training set
train <- data[-honesty_i, ]
# separate honest set
honest <- data[honesty_i, ]
if(all(sort(unique(train[, 1])) == sort(unique(honest[, 1])))){
break
}
}
# initiate repeat indicator
rep_idx <- 1
# initiate repeat indicator
rep_idx <- 1
repeat{
# randomize indices for train and honest sample (take care of uneven numbers with floor and ceiling)
ind <- sample(c(rep(0, ceiling((1-honesty.fraction)*n)), rep(1, floor(honesty.fraction*n))))
# indicator for which observations go into train and honest set
honesty_i <- which(ind == 1)
# separate training set
train <- data[-honesty_i, ]
# separate honest set
honest <- data[honesty_i, ]
# check if in both data sets all outcome categories are represented or if too many tries have been done
if(all(sort(unique(train[, 1])) == sort(unique(honest[, 1]))) | rep_idx == 10){
break
}
# repeat indicator
rep_idx <- rep_idx + 1
}
(all(sort(unique(train[, 1])) != sort(unique(honest[, 1]))))
library(ranger)
ranger(Yo ~ .)
ranger(Yo ~ ., data = data)
ranger(as.numeric(Yo) ~ ., data = data)
boot1 <- ranger(as.numeric(Yo) ~ ., data = data)
set.seed(1)
boot1 <- ranger(as.numeric(Yo) ~ ., data = data, replace = TRUE, sample.fraction = 1)
summary(boot1)
boot1
set.seed(1)
boot05 <- ranger(as.numeric(Yo) ~ ., data = data, replace = TRUE, sample.fraction = 0.5)
boot05
trainData
colnames(data)
colnames(data)[-1]
inference = NULL
is.logical(inference)
X <- as.matrix(honest[,-1])
Y <- as.matrix(honest[,1])
Y <- as.matrix(as.numeric(honest[,1]))
orf(X,Y)
getwd()
library(devtools)
document()
document()
check()
document()
check()
library(orf)
load_all()
wine <- read.csv("~/Documents/HSG/ORF/data_package/wine_multi/wine.data", header=FALSE)
View(wine)
X <- as.matrix(wine[, -1])
Y <- as.matrix(wine[, 1])
Y <- as.matrix(as.numeric(wine[, 1]))
orf_model <- orf(X,Y)
orf_model
predict(orf_model)
orf_model$forestPredictions
predict(orf_model)
orf_model
object <- orf_model
newdata = NULL
inference = NULL
## standard checks for input data
if (class(object) != "orf") {
stop("Forest object is not of class orf. Programme terminated.")
}
## get forest as na object
forest <- object
## save forest inputs
inputs <- forest$forestInfo$inputs
categories <- forest$forestInfo$categories
replace <- inputs$replace
honesty <- inputs$honesty
honest_data <- forest$forestInfo$honestData
train_data <- forest$forestInfo$trainData
honest_ind_data <- forest$forestInfo$indicatorData # indicator data needed for indicator predictions
document()
check()
library(orf)
X <- as.matrix(wine[, -1])
Y <- as.matrix(as.numeric(wine[, 1]))
orf_model <- orf(X,Y)
orf_model
summary(orf_model)
orf_model
predict(orf_model)
kktko <- predict(orf_model)
all(orf_model$forestPredictions == kktko$forestPredictions)
library(grf)
regression_forest(X,Y)
0.054 +0.019 +0.008+ 0.010+ 0.014+ 0.023+ 0.360+ 0.005+ 0.008+ 0.053+ 0.070+ 0.175+ 0.201
library(devtools)
library(grf)
library(ranger)
# set working directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
## load dgp function
source("simulate_data_ORF_function.R")
# general simulation settings
n             <- 10000 # sample size
n_test        <- 1000 # test sample size
# number of discrete values for Y (3,6,9)
Y_n           <- 3
# settings for different DGPs (TRUE/FALSE) - use complicated GDP now
noise             <- TRUE # additional noise variables
highdim           <- FALSE # 1000 noise (zero signal) variables
nonlinear         <- TRUE # nonlinear effects as sin(2X)*beta
multi             <- TRUE # multicollinearity of X
randomcuts        <- FALSE # equal or random cutpoints for Y*
# simulate data
sim_data <- ologit_DGP(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts)
X <- as.matrix(sim_data$odata[, -1])
Y <- as.matrix(as.numeric(sim_data$odata[, 1]))
orf_model <- orf(X,Y)
library(orf)
load_all()
orf_model <- orf(X,Y)
orf_model
kktko <- predict(orf_model)
all(orf_model$forestPredictions == kktko$forestPredictions)
# all(orf_model$forestPredictions == kktko$forestPredictions)
regression_forest(X,Y)
# all(orf_model$forestPredictions == kktko$forestPredictions)
grf_model <- regression_forest(X,Y)
grf_model
ranger_model <- ranger(Yo ~ . , data = sim_data$odata)
ranger_model
ranger_model <- ranger(as.numeric(Yo) ~ . , data = sim_data$odata)
ranger_model
forest <- orf_model
## save forest inputs
main_class        <- class(forest)[1]
main_class
summary(orf_model)
train_data
## save forest inputs
main_class        <- class(forest)[1]
inputs            <- forest$forestInfo$inputs
honesty           <- inputs$honesty
honesty.fraction  <- inputs$honesty.fraction
inference         <- inputs$inference
mtry              <- inputs$mtry
num.trees         <- inputs$num.trees
min.node.size     <- inputs$min.node.size
replace           <- inputs$replace
sample.fraction   <- inputs$sample.fraction
honest_data       <- forest$forestInfo$honestData
train_data        <- forest$forestInfo$trainData
categories        <- length(forest$forestInfo$categories)
type              <- "Ordered Random Forest"
honest_data
sum(nrow(train_data), nrow(honest_data))
build             <- ifelse(replace == TRUE, "Bootstrap", "Subsampling")
library(devtools)
getwd()
document()
check()
document()
check()
document()
check()
library(orf)
load_all()
# set working directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
## load dgp function
source("simulate_data_ORF_function.R")
# general simulation settings
n             <- 10000 # sample size
n_test        <- 1000 # test sample size
# number of discrete values for Y (3,6,9)
Y_n           <- 3
# settings for different DGPs (TRUE/FALSE) - use complicated GDP now
noise             <- TRUE # additional noise variables
highdim           <- FALSE # 1000 noise (zero signal) variables
nonlinear         <- TRUE # nonlinear effects as sin(2X)*beta
multi             <- TRUE # multicollinearity of X
randomcuts        <- FALSE # equal or random cutpoints for Y*
# simulate data
sim_data <- ologit_DGP(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts)
# remove everything
rm(list=setdiff(ls(), c("sim_data")))
X <- as.matrix(sim_data$odata[, -1])
Y <- as.matrix(as.numeric(sim_data$odata[, 1]))
orf_model <- orf(X,Y)
orf_model
library(ranger)
library(grf)
# all(orf_model$forestPredictions == kktko$forestPredictions)
grf_model <- regression_forest(X,Y)
ranger_model <- ranger(as.numeric(Yo) ~ . , data = sim_data$odata)
ranger_model
summary(ranger_model)
summary(grf_model)
summary(orf_model)
orf_model$forestInfo
object <- orf_model
load_all()
## check user inputs
latex <- check_latex(latex)
## get forest as object
forest <- object
## save forest inputs
inputs            <- forest$forestInfo$inputs
honesty           <- inputs$honesty
honesty.fraction  <- inputs$honesty.fraction
inference         <- inputs$inference
mtry              <- inputs$mtry
num.trees         <- inputs$num.trees
min.node.size     <- inputs$min.node.size
replace           <- inputs$replace
sample.fraction   <- inputs$sample.fraction
honest_data       <- forest$forestInfo$honestData
train_data        <- forest$forestInfo$trainData
categories        <- length(forest$forestInfo$categories)
type              <- "Ordered Forest"
inference
honesty
## honest splitting, i.e. use honest data
# take out summary statistics
mse         <- round(forest$MSE, 5)
rps         <- round(forest$RPS, 5)
trainsize   <- nrow(train_data)
honestsize  <- nrow(honest_data)
features    <- ncol(train_data)-1   # take out the response
# check if subsampling or bootstrapping was used
if (forest$trainForests[[1]]$replace == TRUE) { build <- "Bootstrap" } else { build <- "Subsampling" }
build
# structure summary into a list
output        <- list(type, categories, build, num.trees, mtry, min.node.size, replace, sample.fraction, honesty, honesty.fraction, inference, trainsize, honestsize, features, mse, rps)
names(output) <- c("type", "categories", "build", "num.trees", "mtry", "min.node.size", "replace", "sample.fraction", "honesty", "honesty.fraction", "inference", "trainsize", "honestsize", "features", "mse", "rps")
# output matrix
output_matrix <- matrix(NA, ncol = 1, nrow = length(output))
# populate output matrix
rownames(output_matrix) <- names(output) # rownames are names
colnames(output_matrix) <- "" # no colname
output_matrix[, 1]      <- unlist(output) # column 2 are values
# generate latex output if selected
if (latex == TRUE) { colnames(output_matrix) <- "Attributes"
output_matrix <- xtable(output_matrix, caption = "Ordered Forest Summary")
}
latex <- FALSE
# generate latex output if selected
if (latex == TRUE) { colnames(output_matrix) <- "Attributes"
output_matrix <- xtable(output_matrix, caption = "Ordered Forest Summary")
}
# pack it into output
output <- output_matrix
output
latex <- TRUE
orf_model$predictedCategories
table(orf_model$predictedCategories)
table(orf_model$predictedCategories)/length(orf_model$predictedCategories)
(table(orf_model$predictedCategories)/length(orf_model$predictedCategories))*100
paste((table(orf_model$predictedCategories)/length(orf_model$predictedCategories))*100)
paste((table(orf_model$predictedCategories)/length(orf_model$predictedCategories))*100, "%")
paste0((table(orf_model$predictedCategories)/length(orf_model$predictedCategories))*100, "%")
paste0((table(orf_model$predictedCategories)/length(orf_model$predictedCategories))*100, "%")
paste0((table(Y)/length(orf_model$predictedCategories))*100, "%")
# generate latex output if selected
if (latex == TRUE) { colnames(output_matrix) <- "Attributes"
output_matrix <- xtable(output_matrix, caption = "Ordered Forest Summary")
}
output_matrix
output_matrix <- xtable(output_matrix, caption = "Summary of the Ordered Forest Estimation", align = "ll")
output_matrix
orf_model <- orf(X,Y, honesty = FALSE)
honesty.fraction
orf_model <- orf(X,Y, honesty = FALSE, honesty.fraction = 0)
honesty.fraction
honesty.fraction = 0
is.null(honesty.fraction)
!is.null(honesty.fraction)
summary(orf_model)
object <- orf_model
## get forest as object
forest <- object
## save forest inputs
inputs            <- forest$forestInfo$inputs
honesty           <- inputs$honesty
honesty.fraction  <- inputs$honesty.fraction
inference         <- inputs$inference
mtry              <- inputs$mtry
num.trees         <- inputs$num.trees
min.node.size     <- inputs$min.node.size
replace           <- inputs$replace
sample.fraction   <- inputs$sample.fraction
honest_data       <- forest$forestInfo$honestData
train_data        <- forest$forestInfo$trainData
categories        <- length(forest$forestInfo$categories)
type              <- "Ordered Forest"
honesty
inference
## no honest splitting, i.e. use all data
# take out summary statistics
mse         <- round(forest$MSE, 5)
rps         <- round(forest$RPS, 5)
trainsize   <- nrow(train_data)
honestsize  <- 0
nrow(honest_data)
as.numeric(nrow(honest_data))
honest_data
honestsize  <- ifelse(is.null(honest_data), 0, nrow(honest_data))
trainsize
honestsize
## save forest inputs
inputs            <- forest$forestInfo$inputs
honesty           <- inputs$honesty
honesty.fraction  <- inputs$honesty.fraction
inference         <- inputs$inference
mtry              <- inputs$mtry
num.trees         <- inputs$num.trees
min.node.size     <- inputs$min.node.size
replace           <- inputs$replace
sample.fraction   <- inputs$sample.fraction
honest_data       <- forest$forestInfo$honestData
train_data        <- forest$forestInfo$trainData
categories        <- length(forest$forestInfo$categories)
type              <- "Ordered Forest"
## honest splitting, i.e. use honest data
# take out summary statistics
mse         <- round(forest$MSE, 5)
rps         <- round(forest$RPS, 5)
trainsize   <- nrow(train_data)
honestsize  <- ifelse(is.null(honest_data), 0, nrow(honest_data))
features    <- ncol(train_data) - 1   # take out the response
honestsize
# check if subsampling or bootstrapping was used
if (forest$trainForests[[1]]$replace == TRUE) { build <- "Bootstrap" } else { build <- "Subsampling" }
# structure summary into a list
output        <- list(type, categories, build, num.trees, mtry, min.node.size, replace, sample.fraction, honesty, honesty.fraction, inference, trainsize, honestsize, features, mse, rps)
names(output) <- c("type", "categories", "build", "num.trees", "mtry", "min.node.size", "replace", "sample.fraction", "honesty", "honesty.fraction", "inference", "trainsize", "honestsize", "features", "mse", "rps")
# output matrix
output_matrix <- matrix(NA, ncol = 1, nrow = length(output))
# populate output matrix
rownames(output_matrix) <- names(output) # rownames are names
output_matrix
colnames(output_matrix) <- "" # no colname
output
output_matrix
output_matrix[, 1]      <- unlist(output) # column 1 are values
output_matrix
colnames(output_matrix) <- "" # no colname
output_matrix
colnames(output_matrix) <- "Ordered Forest Summary"
output_matrix
colnames(output_matrix) <- NULL # no colname
output_matrix
colnames(output_matrix) <- "" # no colname
colnames(output_matrix) <- "" # no visible colname
output_matrix
lm(as.numeric(Yo) ~ . , data = sim_data$odata)
ols <- lm(as.numeric(Yo) ~ . , data = sim_data$odata)
summary(ols)
library(randomForest)
output
# generate latex output if selected
if (latex == TRUE) { colnames(output_matrix) <- "Ordered Forest Summary"
output_matrix <- xtable(output_matrix, caption = "Summary of the Ordered Forest Estimation", align = "ll")
}
# pack it into output
output <- output_matrix
output
# return output
return(output)
cat(type, "object of class", main_class, "\n\n")
type
cat(type, "object of class", main_class, "\n\n")
## save forest inputs
main_class        <- class(forest)[1]
cat(type, "object of class", main_class, "\n\n")
cat("Summary of the", type, "Estimation \n\n")
cat("Summary of the", type, "Estimation \n\n")
output
# output matrix
output_matrix <- matrix(NA, ncol = 1, nrow = length(output))
# populate output matrix
rownames(output_matrix) <- names(output) # rownames are names
colnames(output_matrix) <- "" # no visible colname
output_matrix[, 1]      <- unlist(output) # column 1 are values
# structure summary into a list
output        <- list(type, categories, build, num.trees, mtry, min.node.size, replace, sample.fraction, honesty, honesty.fraction, inference, trainsize, honestsize, features, mse, rps)
names(output) <- c("type", "categories", "build", "num.trees", "mtry", "min.node.size", "replace", "sample.fraction", "honesty", "honesty.fraction", "inference", "trainsize", "honestsize", "features", "mse", "rps")
# output matrix
output_matrix <- matrix(NA, ncol = 1, nrow = length(output))
# populate output matrix
rownames(output_matrix) <- names(output) # rownames are names
colnames(output_matrix) <- "" # no visible colname
output_matrix[, 1]      <- unlist(output) # column 1 are values
cat("Summary of the", type, "Estimation \n\n")
output
# structure summary into a list
output        <- list(type, categories, build, num.trees, mtry, min.node.size, replace, sample.fraction, honesty, honesty.fraction, inference, trainsize, honestsize, features, mse, rps)
names(output) <- c("type", "categories", "build", "num.trees", "mtry", "min.node.size", "replace", "sample.fraction", "honesty", "honesty.fraction", "inference", "trainsize", "honestsize", "features", "mse", "rps")
# output matrix
output_matrix <- matrix(NA, ncol = 1, nrow = length(output))
# populate output matrix
rownames(output_matrix) <- names(output) # rownames are names
colnames(output_matrix) <- "" # no visible colname
output_matrix[, 1]      <- unlist(output) # column 1 are values
# pack it into output
output <- output_matrix
cat("Summary of the", type, "Estimation \n\n")
output
cat("Summary of the", type, "Estimation \n\n")
output
noquote(output)
# generate latex output if selected
if (latex == TRUE) { colnames(output_matrix) <- "Ordered Forest Summary"
output_matrix <- xtable(output_matrix, caption = "Summary of the Ordered Forest Estimation", align = "ll")
}
# pack it into output
output <- output_matrix
noquote(output)
getwd()
library(devtools)
load_all()
document()
check()
library(orf)
# set working directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
## load dgp function
source("simulate_data_ORF_function.R")
# general simulation settings
n             <- 10000 # sample size
n_test        <- 1000 # test sample size
# number of discrete values for Y (3,6,9)
Y_n           <- 3
# settings for different DGPs (TRUE/FALSE) - use complicated GDP now
noise             <- TRUE # additional noise variables
highdim           <- FALSE # 1000 noise (zero signal) variables
nonlinear         <- TRUE # nonlinear effects as sin(2X)*beta
multi             <- TRUE # multicollinearity of X
randomcuts        <- FALSE # equal or random cutpoints for Y*
# simulate data
sim_data <- ologit_DGP(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts)
# remove everything
rm(list=setdiff(ls(), c("sim_data")))
X <- as.matrix(sim_data$odata[, -1])
Y <- as.matrix(as.numeric(sim_data$odata[, 1]))
orf_model <- orf(X,Y)
orf_model
summary(orf_model)
summary(orf_model, latex = TRUE)
library(devtools)
document()
check()
library(orf)
# set working directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
## load dgp function
source("simulate_data_ORF_function.R")
# general simulation settings
n             <- 10000 # sample size
n_test        <- 1000 # test sample size
# number of discrete values for Y (3,6,9)
Y_n           <- 3
# settings for different DGPs (TRUE/FALSE) - use complicated GDP now
noise             <- TRUE # additional noise variables
highdim           <- FALSE # 1000 noise (zero signal) variables
nonlinear         <- TRUE # nonlinear effects as sin(2X)*beta
multi             <- TRUE # multicollinearity of X
randomcuts        <- FALSE # equal or random cutpoints for Y*
# simulate data
sim_data <- ologit_DGP(Y_n, n, n_test, multi, noise, highdim, nonlinear, randomcuts)
# remove everything
rm(list=setdiff(ls(), c("sim_data")))
X <- as.matrix(sim_data$odata[, -1])
Y <- as.matrix(as.numeric(sim_data$odata[, 1]))
orf_model <- orf(X,Y)
summary(orf_model, latex = TRUE)
summary(orf_model, latex = FALSE)
orf_model
library(devtools)
document()
check()
library(orf)
