rep(1:3, 5)
rep(1:3, each = 5)
matrix(rep(1:3, each = 5), nrow = 5)
matrix(rep(1:3, 5), nrow = 5)
matrix(rep(1:3, 5))
matrix(rep(1:3, 5), ncol = 5)
matrix(rep(1:3, 5), ncol = 3)
matrix(rep(1:3, each = 5), nrow = 5)
matrix(rep(1:3, times = 5,  each = 5), nrow = 5)
matrix(rep(1:3, times = 5,  each = 5))
matrix(rep(1:3, times = 5))
(rep(1:3, times = 5))
matrix(rep(1:3, times = 5)), nrow = 5)
matrix(rep(1:3, times = 5), nrow = 5)
matrix(rep(1:3, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
matrix(rep(1:3, times = 1, each = 5), nrow = 5)
library(devtools)
document()
check()
document()
document()
check()
library(orf)
library(orf)
## Ordered Forest
require(orf)
# load example data
data(odata)
# specify response and covariates
Y <- as.numeric(odata[, 1])
X <- as.matrix(odata[, -1])
# estimate Ordered Forest with default parameters
orf <- orf(X, Y)
margins(orf)
library(orf)
set.seed(1)
orf <- orf(X, Y)
margins(orf)
margins(orf)
View(X_sd)
library(orf)
set.seed(1)
orf <- orf(X, Y)
margins(orf)
View(X_sd)
library(orf)
predictions <- orf$predictions
observed <- Y
observed
rankProbScore <- function(predictions, observed){
ncat <- ncol(predictions)
npred <- nrow(predictions)
rps <- numeric(npred)
for (rr in 1:npred){
obsvec <- rep(0, ncat)
obsvec[observed[rr]] <- 1
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr,1:i]) - sum(obsvec[1:i]))^2
}
rps[rr] <- (1/(ncat-1))*cumulative
}
return(rps)
}
#' Computes the mean ranked probability score (RPS) for evaluating the accuracy of
#' ordered probability predictions
#'
#' @param predictions matrix of predictions (n x categories)
#' @param observed vector of observed ordered categorical outcomes (n x 1)
#'
#' @return scalar, mean RPS for given predictions
#'
#' @keywords internal
#'
rps <- function(predictions, observed){
# ------------------------------------------------------------------------------------ #
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# ------------------------------------------------------------------------------------ #
# prepare 0 vector for rps
rps <- numeric(npred)
# compute the rps (thanks to: https://opisthokonta.net/?p=1333)
for (rr in 1:npred){
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr, 1:i]) - sum(observed_dist[rr, 1:i]))^2
}
rps[rr] <- (1/(ncat - 1))*cumulative
}
# take mean of rps
mrps <- mean(rps)
# ------------------------------------------------------------------------------------ #
# return the mrps
return(mrps)
# ------------------------------------------------------------------------------------ #
}
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
ncat <- ncol(predictions)
npred <- nrow(predictions)
rps <- numeric(npred)
# prepare 0 vector for rps
rps <- numeric(npred)
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
View(observed_dist)
# compute the rps (thanks to: https://opisthokonta.net/?p=1333)
for (rr in 1:npred){
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr, 1:i]) - sum(observed_dist[rr, 1:i]))^2
}
rps[rr] <- (1/(ncat - 1))*cumulative
}
rps
# take mean of rps
mrps <- mean(rps)
mrps
obsvec <- rep(0, ncat)
obsvec
obsvec[observed[rr]] <- 1
obsvec
rankProbScore(predictions, observed)
mean(rankProbScore(predictions, observed))
rps(predictions, observed)
#' Computes the mean ranked probability score (RPS) for evaluating the accuracy of
#' ordered probability predictions
#'
#' @param predictions matrix of predictions (n x categories)
#' @param observed vector of observed ordered categorical outcomes (n x 1)
#'
#' @return scalar, mean RPS for given predictions
#'
#' @keywords internal
#'
rps <- function(predictions, observed){
# ------------------------------------------------------------------------------------ #
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# ------------------------------------------------------------------------------------ #
# prepare 0 vector for rps
rps <- numeric(npred)
# compute the rps (thanks to: https://opisthokonta.net/?p=1333)
for (rr in 1:npred){
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[rr, 1:i]) - sum(observed_dist[rr, 1:i]))^2
}
rps[rr] <- (1/(ncat - 1))*cumulative
}
# take mean of rps
mrps <- mean(rps)
# ------------------------------------------------------------------------------------ #
# return the mrps
return(mrps)
# ------------------------------------------------------------------------------------ #
}
rps(predictions, observed)
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# prepare 0 vector for rps
rps <- numeric(npred)
cumulative <- 0
cumulative <- 0
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[, 1:i]) - sum(observed_dist[, 1:i]))^2
}
cumulative
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (sum(predictions[, 1:i]) - sum(observed_dist[, 1:i]))^2
}
cumulative
cumulative <- numeric(npred)
cumulative
i
i=1
cumulative
sum(predictions[, 1:i])
predictions[, 1:i]
rowSums(predictions[, 1:i])
(matrix(predictions[, 1:i])
)
rowSums(matrix(predictions[, 1:i]))
rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i]))
(rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
cumulative
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
cumulative
(1/(ncat - 1))*cumulative
rps
cumulative <- numeric(npred)
i
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
cumulative
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i])) - rowSums(matrix(observed_dist[, 1:i])))^2
}
observed_dist
predictions
i
predictions[, 1:i]
matrix(predictions[, 1:i])
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i], ncol = i)) - rowSums(matrix(observed_dist[, 1:i], ncol = i)))^2
}
cumulative
rps <- (1/(ncat - 1))*cumulative
rps
mean(rps)
# get parameteres
ncat <- as.numeric(ncol(predictions)) # number of categories
npred <- as.numeric(nrow(predictions)) # number of observations
# create probability distribution for observed outcomes
observed_dist <- matrix(0, nrow = npred, ncol = ncat)
# populate it
for (i in 1:npred) {
observed_dist[i, observed[i]] <- 1
}
# prepare 0 vector for rps
rps <- numeric(npred)
cumulative <- numeric(npred)
for (i in 1:ncat){
cumulative <- cumulative + (rowSums(matrix(predictions[, 1:i], ncol = i)) - rowSums(matrix(observed_dist[, 1:i], ncol = i)))^2
}
rps <- (1/(ncat - 1))*cumulative
mean(rps)
rankProbScore(predictions, observed)
mean(rankProbScore(predictions, observed))
rps
all.equal(rps, rankProbScore(predictions, observed))
repeat_row(apply(X, 2, sd), ntimes = X_rows)
#' repeat rows of a matrix
#'
#' function for replicating rows of a matrix n number of times
#'
#' @param matrix matrix which rows should be replicated
#' @param ntimes number of times to repeat
#'
#' @keywords internal
#'
repeat_row <- function(matrix, ntimes){
# inspired by and thanks to: https://www.r-bloggers.com/a-quick-way-to-do-row-repeat-and-col-repeat-rep-row-rep-col/
matrix(rep(matrix, times = 1, each = ntimes), nrow = ntimes)
}
repeat_row(apply(X, 2, sd), ntimes = X_rows)
X_rows <- nrow(X)
repeat_row(apply(X, 2, sd), ntimes = X_rows)
matrix(rep(apply(X, 2, sd), times = 1, each = X_rows), nrow = X_rows)
document()
check()
library(orf)
check()
document()
check()
document()
check()
library(orf)
document()
check()
library(orf)
document()
check()
library(orf)
packageDescription()
packageDescription(grf)
packageDescription("grf")
packageDescription("orf")
packageDescription("devtools")
packageDescription("orf")
packageDescription("devtools")
packageDescription("grf")
document()
check()
document()
check()
library(orf)
library(ranger)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
set.seed(1, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
set.seed(2, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
set.seed(10, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
ranger(Species ~ ., data = iris)
set.seed(123, sample.kind = "Rounding")
ranger(Species ~ ., data = iris)
library(grf)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
r.forest <- regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
set.seed(123)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
set.seed(123, sample.kind = "Rejection")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
regression_forest(X, Y)
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
r <- regression_forest(X, Y)
set.seed(123, sample.kind = "Rounding")
# Train a standard regression forest.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1] * rnorm(n)
r <- regression_forest(X, Y)
r
summary(r)
r$debiased.error
sessionInfo()
RNGkind()
library(devtools)
document()
check()
library(ranger)
document()
check()
library(orf)
devtools::install()
library(orf)
vignette()
vignette("orf")
library(orf)
library(devtools)
install()
library(orf)
devtools::build()
devtools::build_vignettes()
install()
library(orf)
library(orf)
vignette("orf")
library(orf)
vignette("orf")
library(devtools)
load_all()
vignette("orf")
devtools::build()
devtools::clean_vignettes()
document()
check()
library(orf)
tools::checkRdaFiles()
tools::checkRdaFiles("odata.rda")
tools::checkRdaFiles("/home/okasag/Documents/HSG/Rpackage/orf/orf/data/odata.rda")
document()
check()
library(orf)
## Ordered Forest
require(orf)
# load example data
data(odata)
# specify response and covariates
Y <- as.numeric(odata[, 1])
X <- as.matrix(odata[, -1])
orf <- orf(X, Y, replace = FALSE, honesty = TRUE, inference = TRUE)
orf
orf <- orf(X, Y, replace = FALSE, honesty = TRUE, inference = TRUE)
orf
orfpred <- predict(orf, inference = TRUE)
orfpred <- predict(orf, newdata = X[1:500, ], inference = TRUE)
orfpred <- predict(orf, newdata = X[1:900, ], inference = TRUE)
orfpred <- predict(orf, newdata = X[1:900, ], inference = TRUE)
document()
check()
library(orf)
citation()
citation("orf")
use_citation()
document()
check()
document()
check()
library(orf)
citation()
citation("orf")
document()
check()
library(orf)
citation("orf")
document()
check()
library(orf)
citation("orf")
document()
check()
library(orf)
citation("orf")
document()
check()
library(orf)
citation("orf")
document()
check()
library(orf)
citation("orf")
check(, manual = TRUE)
devtools::build_manual()
document()
check()
devtools::use_readme_rmd()
library(usethis)
usethis::use_readme_rmd()
document()
check()
library(orf)
document()
document()
check()
library(orf)
citation("orf")
print(<Gabriel Okasa and Michael Lechner (2019). orf: Ordered Random Forests R package version 0.1.0>, bibtex=TRUE)'
print(Gabriel Okasa and Michael Lechner (2019). orf: Ordered Random Forests R package version 0.1.0, bibtex=TRUE)
print("Gabriel Okasa and Michael Lechner (2019). orf: Ordered Random Forests R package version 0.1.0", bibtex=TRUE)
print(citation("orf"), bibtex=T)
load("~/Documents/HSG/Rpackage/orf/orf/.RData")
library(devtools)
document()
check()
library(orf)
devtools::build_win()
check_win_release()
document()
check()\
check()
library(orf)
devtools::build()
devtools::build()
